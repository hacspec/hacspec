window.SIDEBAR_ITEMS = {"attr":[["hacspec_unsafe",""],["in_hacspec","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["not_hacspec","Function that is not part of the language but is offered as a helper for tests, etc."],["unsafe_hacspec","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec"]],"enum":[["Bound","An endpoint of a range of keys."],["ControlFlow","Used to tell an operation whether it should exit early or go on as usual."],["GeneratorState","The result of a generator resumption."],["Ordering","An `Ordering` is the result of a comparison between two values."],["Sign","A Sign is a `BigInt`’s composing element."]],"fn":[["I128_from_I16",""],["I128_from_I32",""],["I128_from_I64",""],["I128_from_I8",""],["I16_from_I128","Warning: wrapping semantics."],["I16_from_I32","Warning: wrapping semantics."],["I16_from_I64","Warning: wrapping semantics."],["I16_from_I8",""],["I32_from_I128","Warning: wrapping semantics."],["I32_from_I16",""],["I32_from_I64","Warning: wrapping semantics."],["I32_from_I8",""],["I64_from_I128","Warning: wrapping semantics."],["I64_from_I16",""],["I64_from_I32",""],["I64_from_I8",""],["I8_from_I128","Warning: wrapping semantics."],["I8_from_I16","Warning: wrapping semantics."],["I8_from_I32","Warning: wrapping semantics."],["I8_from_I64","Warning: wrapping semantics."],["U128_from_U16",""],["U128_from_U32",""],["U128_from_U64",""],["U128_from_U8",""],["U128_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U128_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U128_from_usize",""],["U128_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U128_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U16_from_U128","Warning: wrapping semantics."],["U16_from_U32","Warning: wrapping semantics."],["U16_from_U64","Warning: wrapping semantics."],["U16_from_U8",""],["U16_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U16_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U16_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U16_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U32_from_U128","Warning: wrapping semantics."],["U32_from_U16",""],["U32_from_U64","Warning: wrapping semantics."],["U32_from_U8",""],["U32_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U32_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U32_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U32_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U64_from_U128","Warning: wrapping semantics."],["U64_from_U16",""],["U64_from_U32",""],["U64_from_U8",""],["U64_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U64_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U64_from_usize",""],["U64_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U64_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["U8_from_U128","Warning: wrapping semantics."],["U8_from_U16","Warning: wrapping semantics."],["U8_from_U32","Warning: wrapping semantics."],["U8_from_U64","Warning: wrapping semantics."],["U8_from_usize",""],["add_poly","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec Polynomial Addition, calculates a + b mod modulo"],["cadd","Function that is not part of the language but is offered as a helper for tests, etc. Add two numerics if condition `c` is set (all bits 1). Returns `x` if condition `c` is `0`. Note: Addition is always wrapping."],["cmul","Function that is not part of the language but is offered as a helper for tests, etc. Multiply two numerics if condition `c` is set (all bits 1). Returns `x` if condition `c` is `0`. Note: Multiplication is always wrapping."],["cset_bit","Function that is not part of the language but is offered as a helper for tests, etc. Set bit at position `i` in `x` to `b` if `c` is all 1 and return the restult. Returns `x` if `c` is `0`."],["csub","Function that is not part of the language but is offered as a helper for tests, etc. Subtract two numerics if condition `c` is set (all bits 1). Returns `x` if condition `c` is `0`. Note: Addition is always wrapping."],["cswap","Function that is not part of the language but is offered as a helper for tests, etc. Conditional, constant-time swapping. Returns `(x, y)` if `c == 0` and `(y, x)` if `c == T::max`. The return value is undefined if `c` has any other value."],["cswap_bit","Function that is not part of the language but is offered as a helper for tests, etc. Conditional, constant-time swapping. Returns `(x, y)` if `c == 0` and `(y, x)` if `c == 1`."],["ct_div","Function that is not part of the language but is offered as a helper for tests, etc. Constant time division for Numerics. Note that this function is only constant time if `T` is a secret integer and hence provides constant time implementations for the used functions."],["declassify_u128_from_U128","Warning: conversion can be lossy!"],["declassify_u128_from_U32","Warning: conversion can be lossy!"],["declassify_u128_from_U64","Warning: conversion can be lossy!"],["declassify_u128_from_U8","Warning: conversion can be lossy!"],["declassify_u16_from_U16","Warning: conversion can be lossy!"],["declassify_u16_from_U8","Warning: conversion can be lossy!"],["declassify_u32_from_U16","Warning: conversion can be lossy!"],["declassify_u32_from_U32","Warning: conversion can be lossy!"],["declassify_u32_from_U8","Warning: conversion can be lossy!"],["declassify_u64_from_U16","Warning: conversion can be lossy!"],["declassify_u64_from_U32","Warning: conversion can be lossy!"],["declassify_u64_from_U64","Warning: conversion can be lossy!"],["declassify_u64_from_U8","Warning: conversion can be lossy!"],["declassify_u8_from_U8","Warning: conversion can be lossy!"],["declassify_usize_from_U8","Warning: conversion can be lossy!"],["degree_poly","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec Returns degree of polynomial, e.g. for  3x² + 2x + 1 -> 2"],["div_poly","Euclidean polynomial division, calculates `a/b` in `R_n`. Returns `Ok(quotient, remainder)` or `Err(\"Can't divide these two polynomials\")`"],["div_scalar","Function that is not part of the language but is offered as a helper for tests, etc. Scalar division in `R_p`. Returns `a / scalar mod p`."],["extended_euclid","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec Euclidean algorithm to compute the inverse of x in yℤ[x]"],["hex_string_to_bytes","Function that is not part of the language but is offered as a helper for tests, etc."],["make_positive","makes coefficients positiv, e.g. -3 mod 4 = 1"],["min","Compares and returns the minimum of two values."],["mul_poly","Simple polynomial multiplication for two fixed size polynomials O(n²) with `a * b mod n`"],["mul_poly_irr","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec Polynomial multiplication of two size fixed polynomials in R_modulo \\ irr"],["one","Returns the multiplicative identity, `1`."],["poly_to_ring","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec Makes poly to an element of R_modulo \\ irr"],["sub_poly","This function can be called from hacspec programs but its body features Rust constructs that are not part of hacspec polynomial subtraction, calculates a - b mod modulo"],["to_array","Function that is not part of the language but is offered as a helper for tests, etc."],["u128_from_U16","Warning: conversion can be lossy!"],["u128_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u128_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u128_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u128_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u16_from_U128",""],["u16_from_U32",""],["u16_from_U64",""],["u16_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u16_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u16_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u16_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u32_from_U128",""],["u32_from_U64",""],["u32_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u32_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u32_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u32_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u64_from_U128",""],["u64_from_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u64_from_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u64_to_be_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u64_to_le_bytes","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["u8_from_U128",""],["u8_from_U16",""],["u8_from_U32",""],["u8_from_U64",""],["vec_poly_add","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["vec_poly_mul","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["vec_poly_sub","This function is within the hacspec subset of Rust: its signature and body use only hacspec constructs and  call functions whose signatures are in hacspec."],["weight","Returns number of coefficient != 0, e.g. for  -3x⁵ + 3x² + 2x + 1 -> 4"],["zero","Returns the additive identity, `0`."]],"macro":[["Debug","Derive macro generating an impl of the trait `Debug`."],["PartialEq","Derive macro generating an impl of the trait `PartialEq`."],["abstract_int",""],["abstract_nat_mod",""],["abstract_public",""],["abstract_public_modular_integer",""],["abstract_public_nat_mod",""],["abstract_secret",""],["abstract_secret_modular_integer",""],["abstract_signed",""],["abstract_signed_public_integer",""],["abstract_signed_secret_integer",""],["abstract_unsigned",""],["abstract_unsigned_public_integer",""],["abstract_unsigned_secret_integer",""],["define_abstract_integer_checked","Defines a bounded natural integer with regular arithmetic operations, checked for overflow and underflow."],["define_refined_modular_integer","Defines a bounded natural integer with modular arithmetic operations"],["format","Creates a `String` using interpolation of runtime expressions."],["modular_integer",""],["vec","Creates a `Vec` containing the arguments."]],"mod":[["abstract_int",""],["ct_util",""],["fmt","Utilities for formatting and printing strings."],["nat_mod",""],["poly",""],["traits",""],["vec","A contiguous growable array type with heap-allocated contents, written `Vec<T>`."]],"struct":[["BigInt","A big signed integer type."],["BigUint","A big unsigned integer type."],["I128",""],["I16",""],["I32",""],["I64",""],["I8",""],["ParseIntError","An error which can be returned when parsing an integer."],["Range","A (half-open) range bounded inclusively below and exclusively above (`start..end`)."],["RangeFrom","A range only bounded inclusively below (`start..`)."],["RangeFull","An unbounded range (`..`)."],["RangeInclusive","A range bounded inclusively below and above (`start..=end`)."],["RangeTo","A range only bounded exclusively above (`..end`)."],["RangeToInclusive","A range only bounded inclusively above (`..=end`)."],["String","A UTF-8–encoded, growable string."],["U128",""],["U128Word","Fixed length byte array."],["U16",""],["U16Word","Fixed length byte array."],["U32",""],["U32Word","Fixed length byte array."],["U64",""],["U64Word","Fixed length byte array."],["U8",""],["Vec","A contiguous growable array type, written as `Vec<T>`, short for ‘vector’."],["Yeet","Implement `FromResidual<Yeet<T>>` on your type to enable `do yeet expr` syntax in functions returning your type."],["u128Word","Fixed length byte array."],["u16Word","Fixed length byte array."],["u32Word","Fixed length byte array."],["u64Word","Fixed length byte array."]],"trait":[["Add","The addition operator `+`."],["AddAssign","The addition assignment operator `+=`."],["BitAnd","The bitwise AND operator `&`."],["BitAndAssign","The bitwise AND assignment operator `&=`."],["BitOr","The bitwise OR operator `|`."],["BitOrAssign","The bitwise OR assignment operator `|=`."],["BitXor","The bitwise XOR operator `^`."],["BitXorAssign","The bitwise XOR assignment operator `^=`."],["CheckedSub","Performs subtraction that returns `None` instead of wrapping around on underflow."],["CoerceUnsized","Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee."],["Debug","`?` formatting."],["Deref","Used for immutable dereferencing operations, like `*v`."],["DerefMut","Used for mutable dereferencing operations, like in `*v = 1;`."],["DispatchFromDyn","`DispatchFromDyn` is used in the implementation of object safety checks (specifically allowing arbitrary self types), to guarantee that a method’s receiver type can be dispatched on."],["Display","Format trait for an empty format, `{}`."],["Div","The division operator `/`."],["DivAssign","The division assignment operator `/=`."],["Drop","Custom code within the destructor."],["Fn","The version of the call operator that takes an immutable receiver."],["FnMut","The version of the call operator that takes a mutable receiver."],["FnOnce","The version of the call operator that takes a by-value receiver."],["FromResidual","Used to specify which residuals can be converted into which [`crate::ops::Try`] types."],["FromStr","Parse a value from a string"],["Generator","The trait implemented by builtin generator types."],["Index","Used for indexing operations (`container[index]`) in immutable contexts."],["IndexMut","Used for indexing operations (`container[index]`) in mutable contexts."],["Integer","This trait extends the `Numeric` trait and is implemented by all integer types. It offers bit manipulation, instantiation from literal, and convenient constants."],["ModNumeric",""],["Mul","The multiplication operator `*`."],["MulAssign","The multiplication assignment operator `*=`."],["Neg","The unary negation operator `-`."],["Not","The unary logical negation operator `!`."],["Num","The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion."],["Numeric","The `Numeric` trait has to be implemented by all numeric objects."],["NumericCopy",""],["One","Defines a multiplicative identity element for `Self`."],["OneSidedRange","`OneSidedRange` is implemented for built-in range types that are unbounded on one side. For example, `a..`, `..b` and `..=c` implement `OneSidedRange`, but `..`, `d..e`, and `f..=g` do not."],["PartialEq","Trait for equality comparisons which are partial equivalence relations."],["PublicInteger",""],["PublicIntegerCopy",""],["RangeBounds","`RangeBounds` is implemented by Rust’s built-in range types, produced by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`."],["Rem","The remainder operator `%`."],["RemAssign","The remainder assignment operator `%=`."],["Residual","Allows retrieving the canonical type implementing [`Try`] that has this type as its residual and allows it to hold an `O` as its output."],["SecretInteger",""],["SecretIntegerCopy",""],["SeqTrait","Common trait for all byte arrays and sequences."],["Shl","The left shift operator `<<`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust’s type checker has special handling for `_ << _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a << b` and `a.shl(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference."],["ShlAssign","The left shift assignment operator `<<=`."],["Shr","The right shift operator `>>`. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust’s type checker has special handling for `_ >> _`, setting the result type for integer operations to the type of the left-hand-side operand. This means that though `a >> b` and `a.shr(b)` are one and the same from an evaluation standpoint, they are different when it comes to type inference."],["ShrAssign","The right shift assignment operator `>>=`."],["Signed","Useful functions for signed numbers (i.e. numbers that can be negative)."],["SignedInteger",""],["SignedIntegerCopy",""],["Sub","The subtraction operator `-`."],["SubAssign","The subtraction assignment operator `-=`."],["ToString","A trait for converting a value to a `String`."],["Try","The `?` operator and `try {}` blocks."],["TryFrom","Simple and safe type conversions that may fail in a controlled way under some circumstances. It is the reciprocal of [`TryInto`]."],["UnsignedInteger",""],["UnsignedIntegerCopy",""],["UnsignedPublicInteger",""],["UnsignedPublicIntegerCopy",""],["UnsignedSecretInteger",""],["UnsignedSecretIntegerCopy",""],["Zero","Defines an additive identity element for `Self`."]]};